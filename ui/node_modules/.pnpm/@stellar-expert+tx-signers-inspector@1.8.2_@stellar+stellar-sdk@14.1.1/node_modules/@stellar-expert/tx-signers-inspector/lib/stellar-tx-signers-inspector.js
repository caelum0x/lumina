var e,r;e=globalThis,r=e=>(()=>{"use strict";var r={163:r=>{r.exports=e}},s={};function t(e){var o=s[e];if(void 0!==o)return o.exports;var n=s[e]={exports:{}};return r[e](n,n.exports,t),n.exports}t.d=(e,r)=>{for(var s in r)t.o(r,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:r[s]})},t.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r);var o={};return(()=>{t.d(o,{default:()=>f});var e=t(163);class r{constructor(e){this.id=e,this.thresholds={low:!1,med:!1,high:!1}}setThreshold(e){this.thresholds[e]=!0}}const s={ACCOUNT_SIGNATURE:"account_signature",EXTRA_SIGNATURE:"extra_signature"};class n{constructor({requirements:e=[],warnings:r=[]}){this.requirements=e,this.warnings=r,Object.freeze(this)}requirements;warnings;getAllPotentialSigners(){const e=new Set;for(const r of this.requirements)switch(r.type){case s.ACCOUNT_SIGNATURE:{const{signers:s}=r;for(const{key:r}of s)e.add(r)}break;case s.EXTRA_SIGNATURE:e.add(r.key);break;default:throw new Error("Unknown/unsupport requirement type")}return Array.from(e)}}class i extends n{discoverSigners(e,r){const t=[];e=this.normalizeThreshold(e);for(const o of this.requirements)switch(o.type){case s.ACCOUNT_SIGNATURE:{const{signers:s}=o;let n=0;for(const o of s)if((!r||r.includes(o.key))&&(n+=o.weight,t.includes(o.key)||t.push(o.key),n>=e))break;if(n<e||0===n)return[]}break;case s.EXTRA_SIGNATURE:if(r&&!r.includes(o.key))return[];t.push(o.key);break;default:throw new Error("Unknow/unsupported signature requirements type")}return t}checkFeasibility(e,r){return this.discoverSigners(e,r).length>0}checkAuthExtra(e,r){if(!r||!r.length)return[];const s=this.discoverSigners(e,r);if(!s.length)return[];const t=[];for(const e of r)s.includes(e)||t.push(e);return t}normalizeThreshold(e){if("string"==typeof e&&void 0===(e=this.requirements[0].thresholds[e.toLowerCase().split("_")[0]]))throw new Error(`Invalid threshold level: "${e}".`);if("number"!=typeof e)throw new Error(`Invalid threshold level: "${e}".`);return e}}class c extends n{discoverSigners(e){const r=[];for(const t of this.requirements)switch(t.type){case s.ACCOUNT_SIGNATURE:{const{signers:s,minThreshold:o}=t;let n=0;for(const t of s)if((!e||e.includes(t.key))&&(n+=t.weight,r.includes(t.key)||r.push(t.key),n>=o))break;if(n<o||0===n)return[]}break;case s.EXTRA_SIGNATURE:if(e&&!e.includes(t.key))return[];r.push(t.key);break;default:throw new Error("Unknow/unsupported signature requirements type")}return r}checkFeasibility(e){return this.discoverSigners(e).length>0}checkAuthExtra(e){if(!e||!e.length)return[];const r=[],s=[];for(const t of e)s.includes(t)?r.push(t):s.push(t);const t=this.discoverSigners(s);if(!t.length)return r;for(const e of s)t.includes(e)||r.push(e);return r}}class h{constructor(e){if("string"!=typeof e&&void 0===s[e])throw new Error("Invalid type");this.type=e}}class a extends h{constructor(e,r){super(s.ACCOUNT_SIGNATURE),this.id=e,this.minThreshold=r,this.signers=[]}id;minThreshold;signers;thresholds;setThresholds(e){this.thresholds=e}addSigner(e){e.weight>0&&this.signers.push(e)}sortSigners(){this.signers.sort(((e,r)=>{const s=r.weight-e.weight;return 0!==s?s:r.isMaster?1:e.isMaster?-1:e.key>r.key?1:-1}))}}class l extends h{constructor(e){super(s.EXTRA_SIGNATURE),this.key=e}}const u=["low","med","high"];class d{constructor(){this.sources={},this.warnings=[],this.accountsInfo=[]}sources;extraSigners;warnings;accountsInfo;discoverRequiredThreshold(e,r){let s=0;for(const t of u)if(e[t]){const e=r[`${t}_threshold`];e>s&&(s=e)}return s}detectOperationThreshold(e){switch(e.type){case"allowTrust":case"bumpSequence":case"setTrustLineFlags":case"claimClaimableBalance":return"low";case"accountMerge":return"high";case"setOptions":{const r=["masterWeight","lowThreshold","medThreshold","highThreshold","signer"];for(const s of r)if(e[s])return"high"}}return"med"}addSource(s,t){if(e.StrKey.isValidMed25519PublicKey(s)){const r=e.StrKey.decodeMed25519PublicKey(s);s=e.StrKey.encodeEd25519PublicKey(r.slice(0,32))}else if(!e.StrKey.isValidEd25519PublicKey(s))throw new Error(`${s} is not a valid Stellar account public key.`);if(!t||!u.includes(t))throw new Error(`"${t}" is not a valid threshold. Expected one 'low', 'med' or'high'.`);let o=this.sources[s];o||(o=new r(s),this.sources[s]=o),o.setThreshold(t)}addExtraSigners(e){this.extraSigners=e}async loadAccounts(r,s=[]){const t=new e.Horizon.Server(r),o={};for(const e of Object.keys(this.sources)){const r=s.find((r=>r.id===e));if(r&&r.thresholds&&r.signers)o[e]=r;else try{const r=await t.loadAccount(e);delete r._baseAccount,o[e]=r}catch(r){if(r.response&&404===r.response.status){this.warnings.push({code:"no_source",message:`Source account ${e} does not exist on the ledger.`,data:e}),o[e]={id:e,thresholds:{low_threshold:0,med_threshold:0,high_threshold:0},signers:[{public_key:e,weight:1,key:e,type:"ed25519_public_key"}]};continue}throw r}}return this.accountsInfo=o,o}buildSignatureSchema(e){const r=[];for(const e of Object.values(this.sources)){const{id:s,thresholds:t}=e,o=this.accountsInfo[s],{thresholds:n={},signers:i=[{key:s,weight:1}]}=o,c=this.discoverRequiredThreshold(t,n),h=new a(s,c),{low_threshold:l,med_threshold:u,high_threshold:d}=o.thresholds;h.setThresholds({low:l,med:u,high:d});for(const{key:e,weight:r}of i){const t={key:e,weight:r};e===s&&(t.isMaster=!0),h.addSigner(t)}i.length||h.addSigner({key:s,weight:1}),h.sortSigners(),r.push(h)}if(this.extraSigners&&this.extraSigners.constructor===Array&&this.extraSigners.length>0)for(const e of this.extraSigners)r.push(new l(e));let s;switch(e){case"tx":s=c;break;case"account":s=i;break;default:throw new Error(`Invalid schema type: "${e}".`)}return new s({warnings:this.warnings,requirements:r})}}const g="https://horizon.stellar.org",f={inspectTransactionSigners:async function(r,s=null){const t=new d;if(r.feeSource&&r.innerTransaction)t.addSource(r.feeSource,"low");else{if(!(r.source&&r.operations instanceof Array))throw new Error('Invalid parameter "tx". Expected a Stellar transaction.');t.addSource(r.source,"low");for(const e of r.operations)t.addSource(e.source||r.source,t.detectOperationThreshold(e))}r.extraSigners&&r.extraSigners.constructor===Array&&r.extraSigners.length>0&&t.addExtraSigners(r.extraSigners.map((r=>e.SignerKey.encodeSignerKey(r))));const{accountsInfo:o,horizon:n=g}=s||{};return await t.loadAccounts(n,o),t.buildSignatureSchema("tx")},inspectAccountSigners:async function(e,r=null){if(!e)throw new Error('Invalid parameter "sourceAccount". Expected a valid Stellar public key.');const s=new d;for(const r of["low","med","high"])s.addSource(e,r);const{accountsInfo:t,horizon:o=g}=r||{};return await s.loadAccounts(o,t),s.buildSignatureSchema("account")}}})(),o=o.default})(),"object"==typeof exports&&"object"==typeof module?module.exports=r(require("@stellar/stellar-sdk")):"function"==typeof define&&define.amd?define(["@stellar/stellar-sdk"],r):"object"==typeof exports?exports.stellarTxSignersInspector=r(require("@stellar/stellar-sdk")):e.stellarTxSignersInspector=r(e["@stellar/stellar-sdk"]);
//# sourceMappingURL=stellar-tx-signers-inspector.js.map