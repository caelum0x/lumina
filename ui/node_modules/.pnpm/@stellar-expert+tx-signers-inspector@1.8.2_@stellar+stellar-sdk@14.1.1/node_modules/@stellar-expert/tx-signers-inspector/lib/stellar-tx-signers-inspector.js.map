{"version":3,"file":"stellar-tx-signers-inspector.js","mappings":"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","sources":["webpack://stellarTxSignersInspector/webpack/universalModuleDefinition","webpack://stellarTxSignersInspector/external umd2 \"@stellar/stellar-sdk\"","webpack://stellarTxSignersInspector/webpack/bootstrap","webpack://stellarTxSignersInspector/webpack/runtime/define property getters","webpack://stellarTxSignersInspector/webpack/runtime/hasOwnProperty shorthand","webpack://stellarTxSignersInspector/./src/account-thresholds-descriptor.js","webpack://stellarTxSignersInspector/./src/signature-schemas/requirements/signature-requirements-types.js","webpack://stellarTxSignersInspector/./src/signature-schemas/signature-schema.js","webpack://stellarTxSignersInspector/./src/signature-schemas/account-signature-schema.js","webpack://stellarTxSignersInspector/./src/signature-schemas/transaction-signature-schema.js","webpack://stellarTxSignersInspector/./src/signature-schemas/requirements/signature-requirements-base.js","webpack://stellarTxSignersInspector/./src/signature-schemas/requirements/account-signature-requirements.js","webpack://stellarTxSignersInspector/./src/signature-schemas/requirements/extra-signature-requirments.js","webpack://stellarTxSignersInspector/./src/signers-inspector.js","webpack://stellarTxSignersInspector/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@stellar/stellar-sdk\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@stellar/stellar-sdk\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"stellarTxSignersInspector\"] = factory(require(\"@stellar/stellar-sdk\"));\n\telse\n\t\troot[\"stellarTxSignersInspector\"] = factory(root[\"@stellar/stellar-sdk\"]);\n})(globalThis, (__WEBPACK_EXTERNAL_MODULE__163__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__163__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export default class AccountThresholdsDescriptor {\n    /**\n     * @param {String} accountId - Source account.\n     */\n    constructor(accountId) {\n        this.id = accountId\n        this.thresholds = {\n            low: false,\n            med: false,\n            high: false\n        }\n    }\n\n    /**\n     * Mark particular threshold level as required.\n     * @param {'low'|'med'|'high'} threshold\n     */\n    setThreshold(threshold) {\n        this.thresholds[threshold] = true\n    }\n}","const SignatureRequirementsTypes = {\n    ACCOUNT_SIGNATURE: 'account_signature',\n    EXTRA_SIGNATURE: 'extra_signature'\n}\n\nexport default SignatureRequirementsTypes","import SignatureRequirementsTypes from './requirements/signature-requirements-types'\n\n/**\n * Signature scheme analysis result with requirements.\n */\nexport default class SignatureSchema {\n    /**\n     * Create new signature schema for a given transaction/account\n     * @param {Array<SignatureRequirementsBase>} requirements - The requirements tree that fully describes source accounts and weights.\n     * @param {Array<string>} warnings - Detailed description of conditions that can't be fully checked in runtime and may cause a transaction to fail.\n     */\n    constructor({requirements = [], warnings = []}) {\n        this.requirements = requirements\n        this.warnings = warnings\n        Object.freeze(this)\n    }\n\n    /**\n     * The requirements tree that fully describes source accounts and weights required for a transaction to succeed.\n     * @type {Array<SignatureRequirementsBase>}\n     */\n    requirements\n\n    /**\n     * Detailed description of conditions that can't be fully checked in runtime and may cause a transaction to fail.\n     * @type {Array<string>}\n     */\n    warnings\n\n    /**\n     * Retrieve all potential signers for a given transaction/account.\n     * @returns {Array<string>} - A list of all available signers for a given transaction/account.\n     */\n    getAllPotentialSigners() {\n        const allSigners = new Set()\n        for (const requirement of this.requirements) {\n            switch (requirement.type) {\n                case SignatureRequirementsTypes.ACCOUNT_SIGNATURE: {\n                    const {signers} = requirement\n                    for (const {key} of signers) {\n                        allSigners.add(key)\n                    }\n                }\n                    break\n                case SignatureRequirementsTypes.EXTRA_SIGNATURE:\n                    allSigners.add(requirement.key)\n                    break\n                default:\n                    throw new Error('Unknown/unsupport requirement type')\n            }\n        }\n        return Array.from(allSigners)\n    }\n}","import SignatureRequirementsTypes from './requirements/signature-requirements-types'\nimport SignatureSchema from './signature-schema'\n\n/**\n * Signature scheme analysis result with requirements for a given account.\n */\nexport default class AccountSignatureSchema extends SignatureSchema {\n    /**\n     * Discover optimal signers list based on preferred accounts.\n     * @param {'low'|'med'|'high'|Number} threshold - Threshold to meet.\n     * @param {Array<string>} [availableSigners] - Optional constraint, a list of available signers to check (public keys).\n     * @returns {Array<string>} - An optimal transaction signature scheme with respect to restricted availableSigners if provided.\n     */\n    discoverSigners(threshold, availableSigners) {\n        const res = []\n        threshold = this.normalizeThreshold(threshold)\n        for (const requirements of this.requirements) {\n            switch (requirements.type) {\n                case SignatureRequirementsTypes.ACCOUNT_SIGNATURE: {\n                    const {signers} = requirements\n                    let totalWeight = 0\n                    //find optimal signers\n                    for (const signer of signers) {\n                        if (!availableSigners || availableSigners.includes(signer.key)) {\n                            totalWeight += signer.weight\n                            if (!res.includes(signer.key)) {\n                                res.push(signer.key)\n                            }\n                            if (totalWeight >= threshold) break\n                        }\n                    }\n                    //if total weight is still lower than the threshold, it means that we can't find the schema\n                    if (totalWeight < threshold || totalWeight === 0) return []\n                }\n                    break\n                case SignatureRequirementsTypes.EXTRA_SIGNATURE:\n                    //if there is no extra signature signer, it means that we can't find the schema\n                    if (availableSigners && !availableSigners.includes(requirements.key)) return []\n                    res.push(requirements.key)\n                    break\n                default:\n                    throw new Error('Unknow/unsupported signature requirements type')\n            }\n        }\n        return res\n    }\n\n    /**\n     * Check if potential total available weight matches the threshold.\n     * @param {'low'|'med'|'high'|Number} threshold - Threshold to meet.\n     * @param {Array<string>} signers - A potential list of transaction signers.\n     * @returns {Boolean} - True if the total weight of proposed signers is enough for to fully sign the transaction and false otherwise.\n     */\n    checkFeasibility(threshold, signers) {\n        return this.discoverSigners(threshold, signers).length > 0\n    }\n\n    /**\n     * Check for possible TX_BAD_AUTH_EXTRA errors in case if Stellar Core detects more signatures than required for that particular transaction.\n     * @param {'low'|'med'|'high'|Number} threshold - Threshold to meet.\n     * @param {Array<string>} signers - A potential list of transaction signers.\n     * @returns {Array<string>} - A list of unneeded signers that may cause a TX_BAD_AUTH_EXTRA error on submission.\n     */\n    checkAuthExtra(threshold, signers) {\n        //skip if there are no proposed signers - no TX_BAD_AUTH_EXTRA in this case\n        if (!signers || !signers.length) return []\n        //detect optimal signature schema giving the proposes signers\n        const optimalSigners = this.discoverSigners(threshold, signers)\n        //verify that the proposed schema satisfies the requirements\n        if (!optimalSigners.length) return []\n        //the transaction will fail if at least one extra signature is found\n        const unneededSigners = []\n        for (const proposedSigner of signers) {\n            if (!optimalSigners.includes(proposedSigner)) {\n                unneededSigners.push(proposedSigner)\n            }\n        }\n        return unneededSigners\n    }\n\n    /**\n     * Convert threshold level from mnemonic to number if needed.\n     * @param {String|Number} threshold\n     * @return {Number}\n     */\n    normalizeThreshold(threshold) {\n        if (typeof threshold === 'string') {\n            threshold = this.requirements[0].thresholds[threshold.toLowerCase().split('_')[0]]\n            if (threshold === undefined)\n                throw new Error(`Invalid threshold level: \"${threshold}\".`)\n        }\n        if (typeof threshold !== 'number')\n            throw new Error(`Invalid threshold level: \"${threshold}\".`)\n        return threshold\n    }\n}","import SignatureRequirementsTypes from './requirements/signature-requirements-types'\nimport SignatureSchema from './signature-schema'\n\n/**\n * Signature scheme analysis result with requirements for a given transactions.\n */\nexport default class TransactionSignatureSchema extends SignatureSchema {\n    /**\n     * Discover optimal signers list based on preferred accounts.\n     * @param {Array<string>} [availableSigners] - Optional constraint, a list of available signers to check (public keys).\n     * @returns {Array<string>} - An optimal transaction signature scheme with respect to restricted availableSigners if provided.\n     */\n    discoverSigners(availableSigners) {\n        const res = []\n        for (const requirements of this.requirements) {\n            switch (requirements.type) {\n                case SignatureRequirementsTypes.ACCOUNT_SIGNATURE: {\n                    const {signers, minThreshold} = requirements\n                    let totalWeight = 0\n                    //find optimal signers\n                    for (const signer of signers) {\n                        if (!availableSigners || availableSigners.includes(signer.key)) {\n                            totalWeight += signer.weight\n                            if (!res.includes(signer.key)) {\n                                res.push(signer.key)\n                            }\n                            if (totalWeight >= minThreshold) break\n                        }\n                    }\n                    //if total weight is still lower than the threshold, it means that we can't find the schema\n                    if (totalWeight < minThreshold || totalWeight === 0) return []\n                }\n                    break\n                case SignatureRequirementsTypes.EXTRA_SIGNATURE:\n                    //if there is no extra signature signer, it means that we can't find the schema\n                    if (availableSigners && !availableSigners.includes(requirements.key)) return []\n                    res.push(requirements.key)\n                    break\n                default:\n                    throw new Error('Unknow/unsupported signature requirements type')\n\n            }\n        }\n        return res\n    }\n\n    /**\n     * Check if potential total available weight matches the threshold.\n     * @param {Array<string>} signers - A potential list of transaction signers.\n     * @returns {boolean} - True if the total weight of proposed signers is enough for to fully sign the transaction and false otherwise.\n     */\n    checkFeasibility(signers) {\n        return this.discoverSigners(signers).length > 0\n    }\n\n    /**\n     * Check for possible TX_BAD_AUTH_EXTRA errors in case if Stellar Core detects more signatures than required for that particular transaction.\n     * @param {Array<string>} signers - A potential list of transaction signers.\n     * @returns {Array<string>} - A list of unneeded signers that may cause a TX_BAD_AUTH_EXTRA error on submission.\n     */\n    checkAuthExtra(signers) {\n        //skip if there are no proposed signers - no TX_BAD_AUTH_EXTRA in this case\n        if (!signers || !signers.length) return []\n        //check signer uniqueness\n        const unneededSigners = []\n        const uniqueSigners = []\n        for (const proposedSigner of signers) {\n            if (uniqueSigners.includes(proposedSigner)) {\n                unneededSigners.push(proposedSigner)\n            } else {\n                uniqueSigners.push(proposedSigner)\n            }\n        }\n        //detect optimal signature schema giving the proposes signers\n        const optimalSigners = this.discoverSigners(uniqueSigners)\n        //verify that the proposed schema satisfies the requirements\n        if (!optimalSigners.length) return unneededSigners\n        //the transaction will fail if at least one extra signature is found\n        for (const proposedSigner of uniqueSigners) {\n            if (!optimalSigners.includes(proposedSigner)) {\n                unneededSigners.push(proposedSigner)\n            }\n        }\n        return unneededSigners\n    }\n}","import SignatureRequirementsTypes from './signature-requirements-types'\n\nexport default class SignatureRequirementsBase {\n    constructor(type) {\n        if (typeof type !== 'string' && SignatureRequirementsTypes[type] === undefined)\n            throw new Error('Invalid type')\n        this.type = type\n    }\n}","import SignatureRequirementsBase from './signature-requirements-base'\nimport SignatureRequirementsTypes from './signature-requirements-types'\n\n/**\n * @typedef {Object} SignerDescriptor\n * @property {String} key - Signer id.\n * @property {Number} weight - Relative signer weight.\n * @property {Boolean} [isMaster] - True if the signer is an account public key.\n */\n\n/**\n * Required account signatures descriptor.\n */\nexport default class AccountSignatureRequirements extends SignatureRequirementsBase {\n    /**\n     * @param {String} id - Account id.\n     * @param {Number} minThreshold - Minimum required threshold.\n     */\n    constructor(id, minThreshold) {\n        super(SignatureRequirementsTypes.ACCOUNT_SIGNATURE)\n        this.id = id\n        this.minThreshold = minThreshold\n        this.signers = []\n    }\n\n    /**\n     * Account id.\n     * @type {String}\n     */\n    id\n\n    /**\n     * Minimum required threshold.\n     * @type {Number}\n     */\n    minThreshold\n\n    /**\n     * All available signers for the account.\n     * @type {Array<SignerDescriptor>}\n     */\n    signers\n\n    /**\n     * Account operation thresholds.\n     * @type {{low: Number, med: Number, high: Number}}\n     */\n    thresholds\n\n    /**\n     * Set account operation thresholds.\n     * @param {{low: Number, med: Number, high: Number}} thresholds\n     */\n    setThresholds(thresholds) {\n        this.thresholds = thresholds\n    }\n\n    /**\n     * Add available signer to the list.\n     * @param {SignerDescriptor} signer\n     */\n    addSigner(signer) {\n        if (signer.weight > 0) {\n            this.signers.push(signer)\n        }\n    }\n\n    /**\n     * Reorder signers by their weight.\n     */\n    sortSigners() {\n        this.signers.sort((a, b) => {\n            const weightDiff = b.weight - a.weight\n            if (weightDiff !== 0) return weightDiff\n            if (b.isMaster) return 1\n            if (a.isMaster) return -1\n            return a.key > b.key ? 1 : -1\n        })\n    }\n}\n","import SignatureRequirementsBase from './signature-requirements-base'\nimport SignatureRequirementsTypes from './signature-requirements-types'\n\nexport default class ExtraSignatureRequirments extends SignatureRequirementsBase {\n    /**\n     * @param {String} key - Signer id.\n     */\n    constructor(key) {\n        super(SignatureRequirementsTypes.EXTRA_SIGNATURE)\n        this.key = key\n    }\n}","import {Horizon, StrKey, MuxedAccount} from '@stellar/stellar-sdk'\nimport AccountThresholdsDescriptor from './account-thresholds-descriptor'\nimport AccountSignatureSchema from './signature-schemas/account-signature-schema'\nimport TransactionSignatureSchema from './signature-schemas/transaction-signature-schema'\nimport AccountSignatureRequirements from './signature-schemas/requirements/account-signature-requirements'\nimport ExtraSignatureRequirments from './signature-schemas/requirements/extra-signature-requirments'\n\nconst allThresholdLevels = ['low', 'med', 'high']\n\nexport default class SignersInspector {\n    constructor() {\n        this.sources = {}\n        this.warnings = []\n        this.accountsInfo = []\n    }\n\n    /**\n     * @type {Object}\n     */\n    sources\n\n    /**\n     * @type {Array<string>}\n     */\n    extraSigners\n\n    /**\n     * @type {Array<string>}\n     */\n    warnings\n\n    /**\n     * @type {Array<AccountInfo>}\n     */\n    accountsInfo\n\n    discoverRequiredThreshold(requiredThresholds, actualAccountThresholds) {\n        let minThreshold = 0\n        for (const key of allThresholdLevels) {\n            if (requiredThresholds[key]) {\n                const requiredThreshold = actualAccountThresholds[`${key}_threshold`]\n                if (requiredThreshold > minThreshold) {\n                    minThreshold = requiredThreshold\n                }\n            }\n        }\n        return minThreshold\n    }\n\n    detectOperationThreshold(operation) {\n        switch (operation.type) {\n            case 'allowTrust':\n            case 'bumpSequence':\n            case 'setTrustLineFlags':\n            case 'claimClaimableBalance':\n                return 'low'\n            case 'accountMerge':\n                return 'high'\n            case 'setOptions': {\n                const highKeys = ['masterWeight', 'lowThreshold', 'medThreshold', 'highThreshold', 'signer']\n                for (const key of highKeys) {\n                    if (operation[key]) return 'high'\n                }\n            }\n                break\n        }\n        return 'med'\n    }\n\n    /**\n     * Set threshold for a given source account.\n     * @param {String} source - Account address.\n     * @param {'low'|'med'|'high'} threshold - Threshold to meet.\n     */\n    addSource(source, threshold) {\n        if (StrKey.isValidMed25519PublicKey(source)) { //retrieve source account from muxed\n            const raw = StrKey.decodeMed25519PublicKey(source)\n            source = StrKey.encodeEd25519PublicKey(raw.slice(0, 32))\n        } else if (!StrKey.isValidEd25519PublicKey(source))\n            throw new Error(`${source} is not a valid Stellar account public key.`)\n        if (!threshold || !allThresholdLevels.includes(threshold))\n            throw new Error(`\"${threshold}\" is not a valid threshold. Expected one 'low', 'med' or'high'.`)\n        let container = this.sources[source]\n        if (!container) {\n            container = new AccountThresholdsDescriptor(source)\n            this.sources[source] = container\n        }\n        container.setThreshold(threshold)\n    }\n\n    /**\n     * Set extra signers for a given source account.\n     * @param {Array<string>} extraSigners - Extra signers.\n     */\n    addExtraSigners(extraSigners) {\n        this.extraSigners = extraSigners\n    }\n\n    /**\n     * Load account details for a group of source accounts.\n     * @param horizonUrl\n     * @param {Array<AccountInfo>} predefinedAccountsInfo\n     * @return {Promise}\n     */\n    async loadAccounts(horizonUrl, predefinedAccountsInfo = []) {\n        const horizon = new Horizon.Server(horizonUrl)\n        const res = {}\n        for (const source of Object.keys(this.sources)) {\n            const existing = predefinedAccountsInfo.find(ai => ai.id === source)\n            if (existing && existing.thresholds && existing.signers) {\n                res[source] = existing\n                continue\n            }\n            try {\n                const accountInfo = await horizon.loadAccount(source)\n                //cleanup extra information\n                delete accountInfo._baseAccount\n                res[source] = accountInfo\n            } catch (err) {\n                //handle empty accounts\n                if (err.response && err.response.status === 404) {\n                    this.warnings.push({\n                        code: 'no_source',\n                        message: `Source account ${source} does not exist on the ledger.`,\n                        data: source\n                    })\n                    res[source] = {\n                        id: source,\n                        thresholds: {\n                            low_threshold: 0,\n                            med_threshold: 0,\n                            high_threshold: 0\n                        },\n                        signers: [{\n                            public_key: source,\n                            weight: 1,\n                            key: source,\n                            type: 'ed25519_public_key'\n                        }]\n                    }\n                    continue\n                }\n                throw err\n            }\n        }\n        this.accountsInfo = res\n        return res\n    }\n\n    /**\n     * Compose a signature schema for a given input.\n     * @param {('tx'|'account')} type - Schema type.\n     * @return {TransactionSignatureSchema|AccountSignatureSchema}\n     */\n    buildSignatureSchema(type) {\n        const req = []\n\n        for (const source of Object.values(this.sources)) {\n            const {id, thresholds: requiredThresholds} = source\n            const accountInfo = this.accountsInfo[id]\n            const {thresholds = {}, signers = [{key: id, weight: 1}]} = accountInfo\n            //discover minimum sufficient threshold\n            const minThreshold = this.discoverRequiredThreshold(requiredThresholds, thresholds)\n            //discover potential signers\n            const signatureRequirements = new AccountSignatureRequirements(id, minThreshold)\n            //set account operation thresholds\n            const {low_threshold: low, med_threshold: med, high_threshold: high} = accountInfo.thresholds\n            signatureRequirements.setThresholds({low, med, high})\n            //detect min required threshold\n            for (const {key, weight} of signers) {\n                const signer = {key, weight}\n                if (key === id) {\n                    signer.isMaster = true\n                }\n                signatureRequirements.addSigner(signer)\n            }\n            //handle accounts that don't exist yet\n            if (!signers.length) {\n                signatureRequirements.addSigner({key: id, weight: 1})\n            }\n            //reorder by weight to simplify optimal schema calculation\n            signatureRequirements.sortSigners()\n            //add to schema\n            req.push(signatureRequirements)\n        }\n\n        if (this.extraSigners && this.extraSigners.constructor === Array && this.extraSigners.length > 0) {\n            for (const extraSigner of this.extraSigners)\n                req.push(new ExtraSignatureRequirments(extraSigner))\n        }\n\n        let schemaConstructor\n        switch (type) {\n            case 'tx':\n                schemaConstructor = TransactionSignatureSchema\n                break\n            case 'account':\n                schemaConstructor = AccountSignatureSchema\n                break\n            default:\n                throw new Error(`Invalid schema type: \"${type}\".`)\n        }\n\n        return new schemaConstructor({\n            warnings: this.warnings, //copy warnings\n            requirements: req\n        })\n    }\n}\n","import {SignerKey} from '@stellar/stellar-sdk'\nimport SignersInspector from './signers-inspector'\n\nconst defaultHorizon = 'https://horizon.stellar.org'\n\n\n/**\n * @typedef {Object} SigningThresholds\n * @property {number} low_threshold - Account threshold for \"low-threshold\" operations.\n * @property {number} med_threshold - Account threshold for \"medium-threshold\" operations.\n * @property {number} high_threshold - Account threshold for \"high-threshold\" operations.\n */\n\n/**\n * @typedef {Object} AccountInfo\n * @property {String} id - Account id.\n * @property {SigningThresholds} thresholds - Account id.\n * @property {Array<{key: string, weight: number}>} signers - Signers of the account.\n */\n\n/**\n * @typedef {Object} InspectionOptions\n * @property {String} [horizon] - Horizon address used to fetch accounts state if one more source accounts were not provided. Defaults to \"https://horizon.stellar.org\".\n * @property {Array<AccountInfo>} [accountsInfo] - Array containing accounts information pre-fetched from Horizon \"/account/{id}\" endpoint.\n */\n\n/**\n * Discover required signers for a given transaction.\n * @param {Transaction|FeeBumpTransaction} tx - Transaction to assess.\n * @param {InspectionOptions} [options] - Inspection options.\n * @return {Promise<TransactionSignatureSchema>}\n */\nexport async function inspectTransactionSigners(tx, options = null) {\n    //initialize inspector\n    const inspector = new SignersInspector()\n    //check input params using duck typing\n    if (tx.feeSource && tx.innerTransaction) { //fee source tx\n        //add tx source account by default\n        inspector.addSource(tx.feeSource, 'low')\n    } else { //regular tx\n        if (!tx.source || !(tx.operations instanceof Array))\n            throw new Error('Invalid parameter \"tx\". Expected a Stellar transaction.')\n        //add tx source account by default\n        inspector.addSource(tx.source, 'low')\n        //process source account for each operation\n        for (const operation of tx.operations) {\n            inspector.addSource(operation.source || tx.source, inspector.detectOperationThreshold(operation))\n        }\n    }\n    if (tx.extraSigners && tx.extraSigners.constructor === Array && tx.extraSigners.length > 0) {\n        inspector.addExtraSigners(tx.extraSigners.map(signer => SignerKey.encodeSignerKey(signer)))\n    }\n    const {accountsInfo, horizon = defaultHorizon} = options || {}\n    //load all source accounts\n    await inspector.loadAccounts(horizon, accountsInfo)\n    //build and return composed signatures schema\n    return inspector.buildSignatureSchema('tx')\n}\n\n/**\n * Discover required signers for a given account and thresholds.\n * @param {String} sourceAccount - Stellar account to examine.\n * @param {InspectionOptions} [options] - Inspection options.\n * @return {Promise<AccountSignatureSchema>}\n */\nexport async function inspectAccountSigners(sourceAccount, options = null) {\n    if (!sourceAccount)\n        throw new Error('Invalid parameter \"sourceAccount\". Expected a valid Stellar public key.')\n\n    const inspector = new SignersInspector()\n    //analyze all thresholds\n    for (const threshold of ['low', 'med', 'high']) {\n        inspector.addSource(sourceAccount, threshold)\n    }\n    const {accountsInfo, horizon = defaultHorizon} = options || {}\n    //load all source accounts\n    await inspector.loadAccounts(horizon, accountsInfo)\n    //build and return composed signatures schema\n    return inspector.buildSignatureSchema('account')\n}\n\nconst stellarTxSignersInspector = {inspectTransactionSigners, inspectAccountSigners}\n\nexport default stellarTxSignersInspector\n\n/**\n * Discover required signers, weights, and build optimal signature schema for Stellar transactions.\n * @module @stellar-expert/tx-signers-inspector\n */"],"names":["root","factory","globalThis","__WEBPACK_EXTERNAL_MODULE__163__","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","AccountThresholdsDescriptor","constructor","accountId","this","id","thresholds","low","med","high","setThreshold","threshold","ACCOUNT_SIGNATURE","EXTRA_SIGNATURE","SignatureSchema","requirements","warnings","freeze","getAllPotentialSigners","allSigners","Set","requirement","type","SignatureRequirementsTypes","signers","add","Error","Array","from","AccountSignatureSchema","discoverSigners","availableSigners","res","normalizeThreshold","totalWeight","signer","includes","weight","push","checkFeasibility","length","checkAuthExtra","optimalSigners","unneededSigners","proposedSigner","toLowerCase","split","TransactionSignatureSchema","minThreshold","uniqueSigners","SignatureRequirementsBase","AccountSignatureRequirements","super","setThresholds","addSigner","sortSigners","sort","a","b","weightDiff","isMaster","ExtraSignatureRequirments","allThresholdLevels","SignersInspector","sources","accountsInfo","extraSigners","discoverRequiredThreshold","requiredThresholds","actualAccountThresholds","requiredThreshold","detectOperationThreshold","operation","highKeys","addSource","source","StrKey","isValidMed25519PublicKey","raw","decodeMed25519PublicKey","encodeEd25519PublicKey","slice","isValidEd25519PublicKey","container","addExtraSigners","loadAccounts","horizonUrl","predefinedAccountsInfo","horizon","Horizon","Server","keys","existing","find","ai","accountInfo","loadAccount","_baseAccount","err","response","status","code","message","data","low_threshold","med_threshold","high_threshold","public_key","buildSignatureSchema","req","values","signatureRequirements","extraSigner","schemaConstructor","defaultHorizon","inspectTransactionSigners","async","tx","options","inspector","feeSource","innerTransaction","operations","map","SignerKey","encodeSignerKey","inspectAccountSigners","sourceAccount","require","define","amd"],"sourceRoot":""}